---
phase: 04-grocery-lists
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/groceryLists.ts
  - src/utils/ingredientAggregator.ts
autonomous: true

must_haves:
  truths:
    - "Grocery items can be stored with name, quantity, unit, check state"
    - "Generated items can be distinguished from manual items"
    - "Ingredients from multiple recipes aggregate into single items"
    - "Duplicate ingredients with matching units sum their quantities"
  artifacts:
    - path: "convex/schema.ts"
      provides: "groceryItems table with full field structure"
      contains: "groceryItems: defineTable"
    - path: "convex/groceryLists.ts"
      provides: "Grocery list mutations and queries"
      exports: ["generate", "addManualItem", "toggleItem", "uncheckAll", "list", "clearGenerated"]
    - path: "src/utils/ingredientAggregator.ts"
      provides: "Ingredient parsing and aggregation logic"
      exports: ["parseIngredientLine", "aggregateIngredients", "normalizeUnit"]
  key_links:
    - from: "convex/groceryLists.ts"
      to: "convex/schema.ts"
      via: "groceryItems table queries"
      pattern: "ctx\\.db\\.query\\(['\"]groceryItems['\"]\\)"
    - from: "convex/groceryLists.ts"
      to: "convex/mealPlans.ts"
      via: "meal plan queries for generation"
      pattern: "mealPlans"
---

<objective>
Create the backend infrastructure for grocery lists: schema, Convex mutations/queries, and ingredient aggregation utilities.

Purpose: Enable storing grocery items with check state, generating lists from meal plans, and aggregating duplicate ingredients.

Output: Complete Convex API for grocery list operations and client-side aggregation utility.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-grocery-lists/04-CONTEXT.md
@.planning/phases/04-grocery-lists/04-RESEARCH.md

# Reference existing code
@convex/schema.ts
@convex/mealPlans.ts
@src/utils/fractions.ts
@src/utils/dateUtils.ts
@src/constants/household.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend schema and create ingredient aggregator</name>
  <files>convex/schema.ts, src/utils/ingredientAggregator.ts</files>
  <action>
1. **Extend convex/schema.ts** - Update the groceryItems table with full fields:
   ```typescript
   groceryItems: defineTable({
     householdId: v.id('households'),
     name: v.string(),           // Display name (e.g., "Flour")
     quantity: v.optional(v.number()),  // Numeric quantity (optional for "pinch of salt")
     unit: v.optional(v.string()),      // Unit (e.g., "cups")
     displayText: v.string(),    // Full display (e.g., "Flour (3 cups)")
     isChecked: v.boolean(),     // Check-off state
     isGenerated: v.boolean(),   // true = from meal plan, false = manual
     weekStart: v.optional(v.string()), // Which week this was generated for (YYYY-MM-DD)
   })
     .index('by_household', ['householdId'])
     .index('by_household_generated', ['householdId', 'isGenerated']),
   ```

2. **Create src/utils/ingredientAggregator.ts** with these functions:
   - `normalizeUnit(unit: string): string` - Normalize plurals to singular (cups->cup, tablespoons->tbsp)
   - `parseIngredientLine(line: string): ParsedIngredient` - Use existing parseQuantity from fractions.ts, extract unit from known units set, normalize name
   - `aggregateIngredients(lines: string[]): AggregatedItem[]` - Group by name+unit key, sum quantities, round to nearest 1/4, sort alphabetically
   - `formatDisplayText(item: AggregatedItem): string` - Format as "Name (quantity unit)" or just "Name" if no quantity

   Key implementation details:
   - Import parseQuantity from fractions.ts (reuse existing logic)
   - Known units set: cup, cups, tbsp, tablespoon, tablespoons, tsp, teaspoon, teaspoons, oz, ounce, ounces, lb, lbs, pound, pounds, g, gram, grams, kg, ml, liter, liters, clove, cloves, slice, slices, piece, pieces, can, cans, bunch, bunches, head, heads, pinch, dash
   - Capitalize first letter of name for display
   - Round quantities to nearest 0.25 (1/4), always round UP for shopping convenience
   - Handle quantity-less ingredients (e.g., "salt to taste") gracefully
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no errors
    - `npx convex dev` runs without schema errors
  </verify>
  <done>
    - groceryItems table has all required fields and indexes
    - ingredientAggregator.ts exports normalizeUnit, parseIngredientLine, aggregateIngredients, formatDisplayText
    - Aggregation correctly combines "2 cups flour" + "1 cup flour" into "Flour (3 cups)"
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Convex grocery list mutations and queries</name>
  <files>convex/groceryLists.ts</files>
  <action>
Create convex/groceryLists.ts with these functions:

1. **generate** (mutation) - Generate grocery list from next week's meal plans:
   - Args: householdId, weekStart (YYYY-MM-DD of Monday)
   - Calculate weekEnd (weekStart + 6 days)
   - Query mealPlans for date range (use same pattern as listForDateRange)
   - For each meal plan, get recipe and collect ingredients
   - Delete existing generated items (isGenerated: true) for this household
   - Use aggregateIngredients to combine duplicates (import from utils - note: you'll need to copy the logic into Convex since Convex can't import from src/)
   - Insert new grocery items with isGenerated: true, isChecked: false, weekStart
   - Return count of items generated

2. **addManualItem** (mutation) - Add a manual grocery item:
   - Args: householdId, name
   - Insert with isGenerated: false, isChecked: false, displayText: name
   - Return the item ID

3. **toggleItem** (mutation) - Toggle check state:
   - Args: itemId
   - Patch item with isChecked: !currentState
   - Return new state

4. **uncheckAll** (mutation) - Reset all checkmarks:
   - Args: householdId
   - Query all items for household, patch each with isChecked: false

5. **list** (query) - Get all grocery items:
   - Args: householdId
   - Query by_household index
   - Return sorted: generated items first (alphabetically), then manual items (alphabetically)

6. **clearGenerated** (mutation) - Remove all generated items:
   - Args: householdId
   - Delete where isGenerated: true

7. **deleteItem** (mutation) - Delete a single item:
   - Args: itemId
   - Delete the item

**IMPORTANT for generate mutation:** Since Convex backend can't import from src/utils, you must implement the ingredient parsing and aggregation logic directly in groceryLists.ts. Create helper functions at the top of the file:
- Copy the normalizeUnit, parseIngredientLine, aggregateIngredients logic
- The parseQuantity logic can be simplified (just regex for quantities)
  </action>
  <verify>
    - `npx convex dev` shows all functions registered
    - `npx tsc --noEmit` passes
    - In Convex dashboard, functions appear under groceryLists namespace
  </verify>
  <done>
    - groceryLists.ts exports generate, addManualItem, toggleItem, uncheckAll, list, clearGenerated, deleteItem
    - generate mutation correctly aggregates ingredients from recipes
    - Manual items preserved when re-generating (only deletes isGenerated: true)
    - list query returns items sorted alphabetically
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Run `npx convex dev` - schema deploys, functions register
3. Verify in Convex dashboard that groceryLists functions appear
4. Verify groceryItems table structure in Convex dashboard
</verification>

<success_criteria>
- [ ] groceryItems table has householdId, name, quantity, unit, displayText, isChecked, isGenerated, weekStart fields
- [ ] groceryLists.ts has all 7 mutations/queries (generate, addManualItem, toggleItem, uncheckAll, list, clearGenerated, deleteItem)
- [ ] ingredientAggregator.ts exists with parsing and aggregation utilities
- [ ] TypeScript compiles without errors
- [ ] Convex dev deploys successfully
</success_criteria>

<output>
After completion, create `.planning/phases/04-grocery-lists/04-01-SUMMARY.md`
</output>
