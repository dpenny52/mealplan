---
phase: 05-ai-features
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - convex/ai.ts
  - convex/groceryLists.ts
autonomous: true

must_haves:
  truths:
    - "Similar ingredients are combined when generating grocery list"
    - "AI identifies semantic matches (e.g., 'chicken breast' + 'boneless chicken breast')"
    - "Quantities are summed when combining ingredients"
    - "Fallback to existing aggregation if AI unavailable"
  artifacts:
    - path: "convex/ai.ts"
      provides: "AI aggregation action"
      exports: ["aggregateIngredients"]
    - path: "convex/groceryLists.ts"
      provides: "Enhanced generate mutation"
      contains: "aggregateIngredients"
  key_links:
    - from: "convex/groceryLists.ts"
      to: "convex/ai.ts"
      via: "runAction(internal.ai.aggregateIngredients)"
      pattern: "runAction.*aggregateIngredients"
---

<objective>
Add AI-powered ingredient aggregation to grocery list generation

Purpose: Enhance the existing grocery list generation to intelligently combine similar ingredients using Gemini AI. This addresses GROC-02: "AI aggregates similar ingredients intelligently (e.g., combines 'chicken breast' from multiple recipes)".

Output: Grocery list generation that uses AI to identify semantic matches beyond simple string matching, with graceful fallback to existing aggregation if AI is unavailable.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ai-features/05-CONTEXT.md
@.planning/phases/05-ai-features/05-RESEARCH.md
@.planning/phases/05-ai-features/05-01-SUMMARY.md

# Existing implementation to enhance
@convex/groceryLists.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AI aggregation action</name>
  <files>convex/ai.ts</files>
  <action>
Add a new action to convex/ai.ts for intelligent ingredient aggregation.

Add to existing convex/ai.ts file:

```typescript
/**
 * Aggregate grocery ingredients using AI to identify similar items.
 * Combines semantically similar ingredients (e.g., "chicken breast" + "boneless chicken breast").
 */
export const aggregateIngredients = action({
  args: {
    ingredients: v.array(v.string()),
  },
  returns: v.array(v.object({
    name: v.string(),
    quantity: v.optional(v.number()),
    unit: v.optional(v.string()),
    originalItems: v.array(v.string()),
  })),
  handler: async (ctx, args) => {
    const apiKey = process.env.GEMINI_API_KEY;

    // If no API key or empty input, return items as-is (will use fallback)
    if (!apiKey || args.ingredients.length === 0) {
      return args.ingredients.map(item => ({
        name: item,
        quantity: undefined,
        unit: undefined,
        originalItems: [item],
      }));
    }

    try {
      const ai = new GoogleGenAI({ apiKey });

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-lite", // Faster, higher rate limit for frequent calls
        contents: `Aggregate these grocery ingredients, combining similar items intelligently.

Input ingredients:
${args.ingredients.map((item, idx) => `${idx + 1}. ${item}`).join('\n')}

Rules for combining:
1. Combine obvious semantic matches: "chicken breast" + "boneless chicken breast" = "Chicken breast"
2. Sum quantities when units are compatible (both in cups, both in lbs, etc.)
3. Keep items separate if units are incompatible (1 lb vs 2 cups = separate items)
4. Preserve specific variants when they matter: "unsalted butter" vs "salted butter" = separate
5. Normalize names to singular, capitalized form: "tomatoes" -> "Tomato"

Return a JSON array where each item has:
- name: The normalized ingredient name (singular, capitalized)
- quantity: Total quantity (number) or null if no quantity specified
- unit: The unit (normalized: cups->cup, pounds->lb, etc.) or null
- originalItems: Array of the original input strings that were combined

Example:
Input: ["2 cups flour", "1 cup all-purpose flour", "3 chicken breasts", "boneless chicken breast"]
Output: [
  {"name": "Flour", "quantity": 3, "unit": "cup", "originalItems": ["2 cups flour", "1 cup all-purpose flour"]},
  {"name": "Chicken breast", "quantity": 4, "unit": null, "originalItems": ["3 chicken breasts", "boneless chicken breast"]}
]`,
        config: {
          responseMimeType: "application/json",
        },
      });

      const text = response.text;
      if (!text) {
        throw new Error("Empty AI response");
      }

      return JSON.parse(text);
    } catch (error) {
      console.error("AI aggregation error:", error);
      // Return original items for fallback processing
      return args.ingredients.map(item => ({
        name: item,
        quantity: undefined,
        unit: undefined,
        originalItems: [item],
      }));
    }
  },
});
```

Key design decisions:
- Uses gemini-2.5-flash-lite (faster, higher RPM limit for frequent grocery generation)
- Returns originalItems for debugging/transparency
- Graceful degradation: returns input as-is on any error
- Per CONTEXT.md: "Just show totals - no source breakdown of which recipes contributed"
  </action>
  <verify>
`npx convex dev` compiles without errors.
  </verify>
  <done>AI aggregation action exists and handles semantic ingredient matching</done>
</task>

<task type="auto">
  <name>Task 2: Integrate AI aggregation into generate mutation</name>
  <files>convex/groceryLists.ts</files>
  <action>
Update the generate mutation in convex/groceryLists.ts to use AI aggregation when available, falling back to existing logic if AI fails.

Changes to generate mutation:

1. Import the internal API for calling actions:
```typescript
import { internal } from "./_generated/api";
```

2. Convert generate from mutation to action (required to call other actions):
```typescript
// Change: export const generate = mutation({
// To: export const generate = action({
```

3. After collecting all ingredients, try AI aggregation first:
```typescript
// Try AI aggregation first
let aggregated: AggregatedItem[];
try {
  const aiResult = await ctx.runAction(internal.ai.aggregateIngredients, {
    ingredients: allIngredients,
  });

  // Convert AI result to AggregatedItem format
  aggregated = aiResult.map(item => ({
    name: item.name,
    quantity: item.quantity ?? null,
    unit: item.unit ?? null,
  }));
} catch (error) {
  console.log("AI aggregation failed, using fallback:", error);
  // Fallback to existing non-AI aggregation
  aggregated = aggregateIngredients(allIngredients);
}
```

4. Since actions can't directly modify the database, use runMutation for DB operations:
- Create an internal mutation for the DB operations (delete old items, insert new)
- Call it from the action

**Alternative approach (simpler):** Keep generate as a mutation but call the AI action from the client side before calling generate. This avoids the action-calling-mutation complexity.

**Recommended approach:** Create a new `generateWithAI` action that:
1. Collects ingredients (queries meal plans and recipes)
2. Calls AI aggregation
3. Calls an internal mutation to save results

This keeps the existing `generate` mutation as fallback and adds a new AI-enhanced version.

Implementation:
1. Add internal mutation `_saveGeneratedItems` for DB operations
2. Add `generateWithAI` action that orchestrates the flow
3. Keep existing `generate` mutation unchanged for fallback
  </action>
  <verify>
1. `npx convex dev` compiles without errors
2. Generate grocery list (via existing UI) still works
3. AI aggregation is attempted when API key is configured
  </verify>
  <done>Grocery list generation uses AI for semantic ingredient matching with fallback to existing logic</done>
</task>

<task type="auto">
  <name>Task 3: Update grocery UI to use AI generation</name>
  <files>src/app/(tabs)/grocery.tsx</files>
  <action>
Update the grocery screen to use the new AI-enhanced generation when available.

Changes:
1. Import useAction in addition to useMutation
2. Try generateWithAI action first, fall back to generate mutation on error
3. No UI changes needed - same "Generate" button behavior

```typescript
// Add import
import { useAction } from 'convex/react';

// In component
const generateWithAI = useAction(api.groceryLists.generateWithAI);
const generateFallback = useMutation(api.groceryLists.generate);

const handleGenerate = async () => {
  setGenerating(true);
  try {
    // Try AI-enhanced generation first
    await generateWithAI({ householdId: HOUSEHOLD_ID, weekStart });
  } catch (error) {
    console.log("AI generation failed, using fallback:", error);
    // Fallback to non-AI generation
    await generateFallback({ householdId: HOUSEHOLD_ID, weekStart });
  } finally {
    setGenerating(false);
  }
};
```

This provides seamless AI enhancement with invisible fallback - users get smarter aggregation when AI is available without any UX changes.
  </action>
  <verify>
Generate button works. Grocery items are created (check Convex dashboard to see if AI aggregation was used via console logs).
  </verify>
  <done>Grocery UI uses AI-enhanced generation with automatic fallback</done>
</task>

</tasks>

<verification>
1. `npx convex dev` compiles without errors
2. Existing grocery list generation still works (fallback path)
3. With API key configured, AI aggregation is attempted (check Convex logs)
4. Similar ingredients are combined (test: add recipes with "chicken breast" and "boneless chicken breast")
5. Quantities are summed correctly
6. No errors shown to user regardless of AI availability
</verification>

<success_criteria>
- AI aggregation action exists in convex/ai.ts
- Generate mutation/action uses AI when available
- Fallback to existing aggregation works when AI unavailable
- Similar ingredients combined (semantic matching works)
- User sees no difference in UX (same Generate button behavior)
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-features/05-03-SUMMARY.md`
</output>
